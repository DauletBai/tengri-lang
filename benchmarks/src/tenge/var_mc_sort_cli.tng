// FILE: benchmarks/src/tenge/var_mc_sort_cli.tng
// Purpose: Monte Carlo VaR (GBM) using Boxâ€“Muller + full sort (O(N log N)).
// Output: TASK=var_mc_sort,N=<N>,TIME_NS=<elapsed>,VAR=<value>

fn u64_xs_seed(seed: u64) -> u64 {
    if seed == 0 { return 0x9E3779B97F4A7C15; }
    return seed;
}

fn u64_xs_next(state_ptr: &u64) -> u64 {
    var x: u64 = *state_ptr;
    x = x ^ (x >> 12);
    x = x ^ (x << 25);
    x = x ^ (x >> 27);
    *state_ptr = x;
    return x * 0x2545F4914F6CDD1D;
}

fn uniform01(state_ptr: &u64) -> f64 {
    var u: u64 = u64_xs_next(state_ptr) >> 11;
    return f64(u) * (1.0 / 9007199254740992.0);
}

fn normal01(state_ptr: &u64) -> f64 {
    var u1: f64 = uniform01(state_ptr);
    if u1 < 1e-300 { u1 = 1e-300; }
    var u2: f64 = uniform01(state_ptr);
    return sqrt(-2.0 * ln(u1)) * cos(2.0 * PI * u2);
}

fn sort_f64(a: []f64, n: i32) {
    // simple quicksort (iterative two-way partition)
    if n <= 1 { return; }
    var stack_l: []i32 = make_i32(64);
    var stack_r: []i32 = make_i32(64);
    var sp: i32 = 0;
    stack_l[sp] = 0; stack_r[sp] = n - 1; sp = sp + 1;

    while sp > 0 {
        sp = sp - 1;
        var l: i32 = stack_l[sp];
        var r: i32 = stack_r[sp];
        while l < r {
            var i: i32 = l;
            var j: i32 = r;
            var p: f64 = a[(l + r) / 2];
            while i <= j {
                while a[i] < p { i = i + 1; }
                while a[j] > p { j = j - 1; }
                if i <= j {
                    var t: f64 = a[i]; a[i] = a[j]; a[j] = t;
                    i = i + 1; j = j - 1;
                }
            }
            if (j - l) < (r - i) {
                if i < r { stack_l[sp] = i; stack_r[sp] = r; sp = sp + 1; }
                r = j;
            } else {
                if l < j { stack_l[sp] = l; stack_r[sp] = j; sp = sp + 1; }
                l = i;
            }
        }
    }
}

fn main() {
    var N: i32 = argi(1, 1000000);
    var steps: i32 = argi(2, 1);
    var alpha: f64 = argf(3, 0.99);

    var S0: f64 = 100.0;
    var mu: f64 = 0.05;
    var sigma: f64 = 0.20;
    var T: f64 = f64(steps) / 252.0;
    var dt: f64 = T / f64(steps);

    var loss: []f64 = make_f64(N);
    var st: u64 = u64_xs_seed(123456789);

    var t0: i64 = now_ns();
    var i: i32 = 0;
    while i < N {
        var S: f64 = S0;
        var k: i32 = 0;
        while k < steps {
            var z: f64 = normal01(&st);
            var drift: f64 = (mu - 0.5 * sigma * sigma) * dt;
            var diff: f64 = sigma * sqrt(dt) * z;
            S = S * exp(drift + diff);
            k = k + 1;
        }
        loss[i] = -(S - S0);
        i = i + 1;
    }

    sort_f64(loss, N);
    var idx: i32 = N - 1 - i32((1.0 - alpha) * f64(N));
    if idx < 0 { idx = 0; }
    if idx >= N { idx = N - 1; }
    var var_val: f64 = loss[idx];

    var t1: i64 = now_ns();
    var elapsed: i64 = t1 - t0;

    print("TASK=var_mc_sort,N="); printi(N);
    print(",TIME_NS="); printi(elapsed);
    print(",VAR="); printf(var_val, 6); print("\n");
}