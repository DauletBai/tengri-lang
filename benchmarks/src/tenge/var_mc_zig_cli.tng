// FILE: benchmarks/src/tenge/var_mc_zig_cli.tng
// Purpose: Monte Carlo VaR (GBM) using Ziggurat normal generator + full sort.
// Output: TASK=var_mc_zig,N=<N>,TIME_NS=<elapsed>,VAR=<value>

fn u64_xs_seed(seed: u64) -> u64 {
    if seed == 0 { return 0x9E3779B97F4A7C15; }
    return seed;
}

fn u64_xs_next(state_ptr: &u64) -> u64 {
    var x: u64 = *state_ptr;
    x = x ^ (x >> 12);
    x = x ^ (x << 25);
    x = x ^ (x >> 27);
    *state_ptr = x;
    return x * 0x2545F4914F6CDD1D;
}

// Precomputed tables for Ziggurat (128 layers). Values are standard set for N(0,1).
// For simplicity in the demo, tables are generated ahead of time and embedded.
const ZIG_R: f64 = 3.442619855899;    // tail cutoff
const ZIG_INV_R: f64 = 1.0 / ZIG_R;

const zig_x[129]: f64 = {
    3.713086246740, 3.442619855899, 3.223084984578, 3.083228858216, 2.978696252647,
    2.894344007019, 2.823125350548, 2.761169372286, 2.706113573119, 2.656406411259,
    2.610972248428, 2.569033625924, 2.530010240221, 2.493457369855, 2.459018177410,
    2.426400252942, 2.395362534774, 2.365703151121, 2.337250756573, 2.309857274401,
    2.283392779016, 2.257741442219, 2.232799516605, 2.208472701532, 2.184674478490,
    2.161325530309, 2.138352161505, 2.115685757570, 2.093262315344, 2.071021998623,
    2.048908755913, 2.026869017441, 2.004851427104, 1.982806617372, 1.960686993962,
    1.938446463114, 1.916040252994, 1.893424732083, 1.870557257243, 1.847395041048,
    1.823894034139, 1.800008806293, 1.775691455004, 1.750890542681, 1.725550061133,
    1.699608381616, 1.673997226122, 1.647640652104, 1.620453028623, 1.592336021002,
    1.563176605944, 1.532844131841, 1.501187233627, 1.468029285510, 1.433161927236,
    1.396338520342, 1.357251772698, 1.315510551578, 1.270579286269, 1.221653345322,
    1.167516788538, 1.106842816421, 1.037314720727, 0.955242247089, 0.854753190635,
    0.724597525270, 0.546082246193, 0.298741512247, 0.000000000000, 0.0
};

const zig_y[129]: f64 = {
    0.000000000000, 0.002669629083, 0.005548995220, 0.008616049314, 0.011848249446,
    0.015224797764, 0.018726306024, 0.022334586345, 0.026032444293, 0.029803507224,
    0.033632081515, 0.037502980167, 0.041401422775, 0.045312939729, 0.049223288290,
    0.053118446590, 0.056984626090, 0.060808309586, 0.064576309530, 0.068275837491,
    0.071894571891, 0.075420740170, 0.078843194494, 0.082151511210, 0.085335102391,
    0.088384327731, 0.091290632173, 0.094046675118, 0.096646467223, 0.099085510165,
    0.101360925011, 0.103471548533, 0.105417999672, 0.107202718981, 0.108829996002,
    0.110306003874, 0.111638817240, 0.112838427538, 0.113916744246, 0.114887585293,
    0.115766654987, 0.116571522172, 0.117321572752, 0.118037957728, 0.118743520275,
    0.119462709101, 0.120221462444, 0.121047083725, 0.121968107869, 0.123014145236,
    0.124215690093, 0.125604879480, 0.127215225941, 0.129081361763, 0.131238819135,
    0.133723852717, 0.136572375761, 0.139818999595, 0.143495163124, 0.147627263907,
    0.152233899679, 0.157321197585, 0.162879231358, 0.168877573620, 0.175257410941,
    0.181924907008, 0.188735170653, 0.195471201528, 0.201792000000, 0.0
};

// Ziggurat normal generator
fn normal01_zig(state_ptr: &u64) -> f64 {
    while true {
        var u: u64 = u64_xs_next(state_ptr);
        var i: i32 = i32(u & 127);
        var sign: f64 = if ((u >> 8) & 1) == 0 { 1.0 } else { -1.0 };
        var x: f64 = f64(u >> 12) * (1.0 / 4503599627370496.0) * zig_x[i]; // uniform * x[i]
        if f64(u & 0xFFFFFFFF) * (1.0 / 4294967296.0) < (zig_y[i+1] / zig_y[i]) {
            return sign * x;
        }
        if i == 0 {
            // tail
            var r: f64 = -ln( uniform01(state_ptr) ) * ZIG_INV_R;
            return sign * (ZIG_R + r);
        } else {
            var x_left: f64 = zig_x[i+1];
            var x_right: f64 = zig_x[i];
            var y_bottom: f64 = zig_y[i+1];
            var y_top: f64 = zig_y[i];
            var y: f64 = y_bottom + (y_top - y_bottom) * uniform01(state_ptr);
            if y < exp(-0.5 * x * x) {
                return sign * x;
            }
        }
    }
}

fn sort_f64(a: []f64, n: i32) {
    if n <= 1 { return; }
    var stack_l: []i32 = make_i32(64);
    var stack_r: []i32 = make_i32(64);
    var sp: i32 = 0;
    stack_l[sp] = 0; stack_r[sp] = n - 1; sp = sp + 1;
    while sp > 0 {
        sp = sp - 1;
        var l: i32 = stack_l[sp];
        var r: i32 = stack_r[sp];
        while l < r {
            var i: i32 = l;
            var j: i32 = r;
            var p: f64 = a[(l + r) / 2];
            while i <= j {
                while a[i] < p { i = i + 1; }
                while a[j] > p { j = j - 1; }
                if i <= j {
                    var t: f64 = a[i]; a[i] = a[j]; a[j] = t;
                    i = i + 1; j = j - 1;
                }
            }
            if (j - l) < (r - i) {
                if i < r { stack_l[sp] = i; stack_r[sp] = r; sp = sp + 1; }
                r = j;
            } else {
                if l < j { stack_l[sp] = l; stack_r[sp] = j; sp = sp + 1; }
                l = i;
            }
        }
    }
}

fn main() {
    var N: i32 = argi(1, 1000000);
    var steps: i32 = argi(2, 1);
    var alpha: f64 = argf(3, 0.99);

    var S0: f64 = 100.0;
    var mu: f64 = 0.05;
    var sigma: f64 = 0.20;
    var T: f64 = f64(steps) / 252.0;
    var dt: f64 = T / f64(steps);

    var loss: []f64 = make_f64(N);
    var st: u64 = u64_xs_seed(123456789);

    var t0: i64 = now_ns();
    var i: i32 = 0;
    while i < N {
        var S: f64 = S0;
        var k: i32 = 0;
        while k < steps {
            var z: f64 = normal01_zig(&st);
            var drift: f64 = (mu - 0.5 * sigma * sigma) * dt;
            var diff: f64 = sigma * sqrt(dt) * z;
            S = S * exp(drift + diff);
            k = k + 1;
        }
        loss[i] = -(S - S0);
        i = i + 1;
    }

    sort_f64(loss, N);
    var idx: i32 = N - 1 - i32((1.0 - alpha) * f64(N));
    if idx < 0 { idx = 0; }
    if idx >= N { idx = N - 1; }
    var var_val: f64 = loss[idx];

    var t1: i64 = now_ns();
    var elapsed: i64 = t1 - t0;

    print("TASK=var_mc_zig,N="); printi(N);
    print(",TIME_NS="); printi(elapsed);
    print(",VAR="); printf(var_val, 6); print("\n");
}
