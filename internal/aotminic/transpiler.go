package aotminic

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// TranspileToC emits a single C file at outC based on the source name.
// It supports two demo patterns:
//   - fib_iter_cli.tgr → iterative Fibonacci
//   - fib_rec_cli.tgr  → recursive Fibonacci
// If 'force' is true, любое имя будет воспринято как iterative-демо.
func TranspileToC(srcPath string, outC string, force bool) error {
	base := filepath.Base(srcPath)
	kind := ""
	switch {
	case strings.Contains(base, "fib_iter_cli"):
		kind = "iter"
	case strings.Contains(base, "fib_rec_cli"):
		kind = "rec"
	default:
		if force {
			kind = "iter"
		}
	}

	if kind == "" {
		return fmt.Errorf("cannot detect program kind (expected fib_iter_cli / fib_rec_cli); got: %s", base)
	}

	var csrc string
	switch kind {
	case "iter":
		csrc = cTemplateIter
	case "rec":
		csrc = cTemplateRec
	default:
		return errors.New("internal kind switch error")
	}

	// Ensure dir exists and write file atomically-ish
	if err := os.MkdirAll(filepath.Dir(outC), 0o755); err != nil {
		return err
	}
	if err := os.WriteFile(outC, []byte(csrc), 0o644); err != nil {
		return err
	}

	fmt.Printf("C emitted: %s\n", outC)
	return nil
}

// --------------------- C templates (runtime v2: tgr_*) ---------------------

const cTemplateIter = `// Auto-generated by tengri-aot (demo). Do not edit by hand.
#include "runtime.h"
#include <stdint.h>

static inline long fib_iter(long n) {
    if (n <= 1) return n;
    long a = 0, b = 1;
    for (long i = 2; i <= n; i++) {
        long c = a + b;
        a = b;
        b = c;
    }
    return b;
}

int main(int argc, char** argv) {
    // N=40 by default; BENCH_REPS from env (runtime provides default=1)
    long n        = tgr_argi(argc, argv, 1, 40);
    int64_t reps  = tgr_bench_reps();

    // warm-up
    (void)fib_iter(10);

    int64_t t0 = tgr_time_ns();
    long res = 0;
    for (int64_t i = 0; i < reps; i++) {
        res = fib_iter(n);
    }
    int64_t t1 = tgr_time_ns();

    tgr_print_long(res);
    tgr_print_time_ns(t1 - t0, reps);
    return 0;
}
`

const cTemplateRec = `// Auto-generated by tengri-aot (demo). Do not edit by hand.
#include "runtime.h"
#include <stdint.h>

static inline long fib_rec(long n) {
    if (n <= 1) return n;
    return fib_rec(n - 1) + fib_rec(n - 2);
}

int main(int argc, char** argv) {
    // N=34 by default; BENCH_REPS from env (runtime provides default=1)
    long n        = tgr_argi(argc, argv, 1, 34);
    int64_t reps  = tgr_bench_reps();

    // warm-up
    (void)fib_rec(10);

    int64_t t0 = tgr_time_ns();
    long res = 0;
    for (int64_t i = 0; i < reps; i++) {
        res = fib_rec(n);
    }
    int64_t t1 = tgr_time_ns();

    tgr_print_long(res);
    tgr_print_time_ns(t1 - t0, reps);
    return 0;
}
`